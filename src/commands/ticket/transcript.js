const { SlashCommandBuilder, PermissionFlagsBits, AttachmentBuilder } = require('discord.js');
const { success, error } = require('../../utils/responseBuilder');
const ticketManager = require('../../database/ticketManager');
const config = require('../../config');

module.exports = {
  data: new SlashCommandBuilder()
    .setName('ticket-transcript')
    .setDescription('Generate a transcript of the ticket'),
    
  async execute(interaction) {
    await interaction.deferReply();
    
    const guildId = interaction.guild.id;
    const channelId = interaction.channel.id;
    
    // Check if this channel is a ticket
    const ticket = ticketManager.getTicketByChannelId(channelId);
    
    if (!ticket) {
      return interaction.editReply({ 
        embeds: [error('Not a Ticket', 'This command can only be used in a ticket channel.')] 
      });
    }
    
    // Get ticket messages
    const messages = ticket.messages;
    
    // If no messages recorded, fetch from channel
    if (!messages || messages.length === 0) {
      try {
        // Fetch all messages from channel
        const fetchedMessages = await interaction.channel.messages.fetch({ limit: 100 });
        
        // Store messages in ticket
        fetchedMessages.forEach(msg => {
          ticketManager.addMessageToTicket(channelId, msg);
        });
      } catch (err) {
        return interaction.editReply({ 
          embeds: [error('Failed to Fetch Messages', `Error: ${err.message}`)] 
        });
      }
    }
    
    await generateAndSendTranscript(interaction, ticket);
  },
  
  // Handle button interactions
  async handleButton(interaction) {
    await interaction.deferReply();
    
    const channelId = interaction.channel.id;
    
    // Check if this channel is a ticket
    const ticket = ticketManager.getTicketByChannelId(channelId);
    
    if (!ticket) {
      return interaction.editReply({ 
        content: 'This is not a ticket channel.'
      });
    }
    
    await generateAndSendTranscript(interaction, ticket);
  }
};

// Common function to generate and send transcript
async function generateAndSendTranscript(interaction, ticket) {
  try {
    // Get updated messages
    const messages = ticketManager.getTicketTranscript(ticket.channelId);
    
    // Generate HTML transcript
    const html = generateHtmlTranscript(ticket, messages || []);
    
    // Create attachment
    const attachment = new AttachmentBuilder(Buffer.from(html), { 
      name: `transcript-${ticket.id}.html`,
      description: `Ticket transcript for ${ticket.id}`
    });
    
    // Send transcript
    await interaction.editReply({ 
      embeds: [success('Transcript Generated', 'The ticket transcript has been generated.')],
      files: [attachment]
    });
    
    // Log to ticket logs
    const settings = ticketManager.getTicketSettings(ticket.guildId);
    if (settings && settings.logsChannel) {
      const guild = interaction.guild;
      const logsChannel = guild.channels.cache.get(settings.logsChannel) ||
                        guild.channels.cache.find(c => c.name === settings.logsChannel);
      
      if (logsChannel) {
        await logsChannel.send({
          content: `Transcript for ticket ${ticket.id} generated by <@${interaction.user.id}>`,
          files: [attachment]
        });
      }
    }
  } catch (err) {
    return interaction.editReply({ 
      embeds: [error('Failed to Generate Transcript', `Error: ${err.message}`)] 
    });
  }
}

// Function to generate HTML transcript
function generateHtmlTranscript(ticket, messages) {
  // Get basic ticket info
  const ticketInfo = {
    id: ticket.id,
    creator: ticket.userId,
    type: ticket.type,
    createdAt: new Date(ticket.createdAt).toLocaleString(),
    status: ticket.status,
  };
  
  // Start building HTML content
  let html = `
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ticket Transcript - ${ticket.id}</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        color: #333;
      }
      .ticket-info {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
      }
      .message {
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 5px;
        border: 1px solid #ddd;
      }
      .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .message-content {
        white-space: pre-wrap;
      }
      .attachment {
        margin-top: 5px;
      }
      .attachment a {
        color: #0066cc;
      }
      .no-messages {
        font-style: italic;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>Ticket Transcript</h1>
    <div class="ticket-info">
      <p><strong>Ticket ID:</strong> ${ticketInfo.id}</p>
      <p><strong>Created By:</strong> User ID: ${ticketInfo.creator}</p>
      <p><strong>Type:</strong> ${ticketInfo.type}</p>
      <p><strong>Created At:</strong> ${ticketInfo.createdAt}</p>
      <p><strong>Status:</strong> ${ticketInfo.status}</p>
    </div>
    <h2>Messages</h2>
  `;
  
  if (messages.length === 0) {
    html += '<p class="no-messages">No messages were recorded for this ticket.</p>';
  } else {
    // Sort messages chronologically
    const sortedMessages = [...messages].sort((a, b) => {
      return new Date(a.timestamp) - new Date(b.timestamp);
    });
    
    // Add each message
    sortedMessages.forEach(msg => {
      const timestamp = new Date(msg.timestamp).toLocaleString();
      
      html += `
      <div class="message">
        <div class="message-header">
          <span>User ID: ${msg.author}</span>
          <span>${timestamp}</span>
        </div>
        <div class="message-content">${escapeHtml(msg.content || '[No text content]')}</div>
      `;
      
      // Add attachments if any
      if (msg.attachments && msg.attachments.length > 0) {
        html += '<div class="attachments">';
        msg.attachments.forEach((url, i) => {
          html += `
          <div class="attachment">
            <a href="${url}" target="_blank">Attachment ${i+1}</a>
          </div>
          `;
        });
        html += '</div>';
      }
      
      html += '</div>';
    });
  }
  
  // Close HTML
  html += `
    <footer>
      <p>Transcript generated on ${new Date().toLocaleString()}</p>
    </footer>
  </body>
  </html>
  `;
  
  return html;
}

// Helper function to escape HTML
function escapeHtml(text) {
  if (!text) return '';
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
